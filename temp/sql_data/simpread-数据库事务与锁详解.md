# 数据库--事务操作
>[原文地址](https://www.jianshu.com/p/eb41df600775)

## 什么是事务（Transaction）？

**事务**是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。

事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。

一个逻辑工作单元要成为事务，必须满足所谓的 `ACID`（**原子性**、**一致性**、**隔离性** 和**持久性**）属性。事务是数据库运行中的一个逻辑工作单位，由 `DBMS`(Data Base Manager System) 中的事务管理子系统负责事务的处理。

## 事务的 4 个特性

- **原子性(Atomic)**：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。

- **一致性(Consistency)**：事务的一致性指的是在**一个事务执行之前和执行之后数据库都必须处于一致性状态**。这种特性称为事务的一致性。假如数据库的状态满足所有的完整性约束，就说该数据库是一致的。<!-- 事务的一致性定义基本可以理解为是事务对数据完整性约束的遵循。这些约束可能包括主键约束、外键约束或是一些用户自定义约束。事务执行的前后都是合法的数据状态，不会违背任何的数据完整性，这就是 “一致” 的意思。 当然这个含义中也隐含着对开发者的要求，就是不能写出错误的事务逻辑，比如银行的转账不能只加钱不减钱，这是应用层面的一致性要求。 -->

- **隔离性 (Isolation)**：由**并发事务所作的修改必须与任何其它并发事务所作的修改隔离**。事务查看数据时数据所处的状态，到底是另一个事务执行之前的状态还是中间某个状态，相互之间存在什么影响，是可以通过隔离级别的设置来控制的。<!-- 保证并行事务处理能够达到 “互不干扰” 的效果。 -->

- **持久性 (Durability)**：**事务结束后，事务处理的结果必须能够得到固化，即写入数据库文件中即使机器宕机数据也不会丢失**，它对于系统的影响是永久性的。<!-- 持久性就是指，事务一旦被提交，那么数据一定会被写入到数据库中并持久储存起来。另外，当事务被提交后就无法再回滚，如果想要撤销一个已经提交的事务，那就只能执行一个效果与其相反的事务，这也是持久性的一种体现。 -->

## 事务并发控制
我们从另外一个方向来说说，如果不对事务进行并发控制，我们看看数据库并发操作是会有那些异常情形，有些使我们可以接受的，有些是不能接受的，注意这里的异常就是特定语境下的，并不一定就是错误什么的。假设有一个 `order` 表，有个字段叫 `count`，作为计数用，当前值为 `100`

- **第一类丢失更新（Update Lost）**：此种更新丢失是*因为回滚的原因*，所以也叫*回滚丢失*。此时两个事务同时更新 `count`，两个事务都读取到 `100`，事务一更新成功并提交，`count=100+1=101`，事务二出于某种原因更新失败了，然后回滚，事务二就把 `count` 还原为它一开始读到的 `100`，此时事务一的更新就这样丢失了。

- **脏读（Dirty Read）**：此种异常时因为*一个事务读取了另一个事务修改了但是未提交的数据*。举个例子，事务一更新了 `count=101`，但是没有提交，事务二此时读取 `count`，值为 `101` 而不是 `100`，然后事务一出于某种原因回滚了，然后第二个事务读取的这个值就是噩梦的开始。

- **不可重复读（Not Repeatable Read）**：此种异常是*一个事务对同一行数据执行了两次或更多次查询，但是却得到了不同的结果*，也就是在一个事务里面你不能重复（即多次）读取一行数据，如果你这么做了，不能保证每次读取的结果是一样的，有可能一样有可能不一样。造成这个结果是**在两次查询之间有别的事务对该行数据做了更新操作**。举个例子，事务一先查询了 `count`，值为 `100`，此时事务二更新了 `count=101`，事务一再次读取 `count`, 值就会变成 `101`，两次读取结果不一样。

- **第二类丢失更新（Second Update Lost）**：此种更新丢失是因为*更新被其他事务给覆盖了*，也可以叫*覆盖丢失*。举个例子，两个事务同时更新 `count`，都读取 `100` 这个初始值，事务一先更新成功并提交，`count=100+1=101`，事务二后更新成功并提交，`count=100+1=101`, 由于事务二 `count` 还是从 `100` 开始增加，事务一的更新就这样丢失了。

- **幻读（Phantom Read）**：*幻读和不可重复读有点像，只是针对的不是数据的值而是数据的数量*。此种异常是一个事务在两次查询的过程中数据的数量不同，让人以为发生幻觉，幻读大概就是这么得来的吧。举个例子，事务一查询 `order` 表有多少条记录，事务二新增了一条记录，然后事务一查了一下 `order` 表有多少记录，发现和第一次不一样，这就是幻读。
>此处将幻读与不可重复读分离，学习教材《数据库与安全》未分离


## 数据库事务隔离级别
上面几种情况并不是一定都要避免的，具体看你的业务要求，包括你数据库的负载都会影响你的决定。上面各种异常情况都是多个事务之间相互影响造成的，这说明*两个事务之间需要某种方式将他们从某种程度上分开，降低直至避免相互影响*。这时候数据库事务隔离级别就粉墨登场了，而数据库的隔离级别实现一般是通过数据库锁实现的。

- **读未提交（Read Uncommitted）**：该隔离级别指即使一个事务的更新语句没有提交, 但是别的事务可以读到这个改变，几种异常情况都可能出现。极易出错，没有安全性可言，基本不会使用。

- **读已提交（Read Committed）**：该隔离级别指一个事务只能看到其他事务的已经提交的更新，看不到未提交的更新，**消除了脏读和第一类丢失更新**，这是大多数数据库的默认隔离级别，如 Oracle,Sqlserver。

- **可重复读（Repeatable Read）**：该隔离级别指一个事务中进行两次或多次同样的对于数据内容的查询，得到的结果是一样的，但不保证对于数据条数的查询是一样的，**只要存在读改行数据就禁止写**，**消除了不可重复读和第二类更新丢失**，这是 Mysql 数据库的默认隔离级别。<!-- 共享读，互斥写 -->

- **串行化（Serializable）**：意思是说这个事务执行的时候不允许别的事务并发执行. 完全串行化的读，**只要存在读就禁止写, 但可以同时读，消除了幻读**。这是事务隔离的最高级别，虽然最安全最省心，但是效率太低，一般不会用。<!-- 共享读，互斥写 -->
>此处串行化读与可重复度

### 下面是各种隔离级别对各异常的控制能力：

| 级别 \ 异常 | 第一类更新丢失 | 脏读 | 不可重复读 | 第二类丢失更新 | 幻读 |
| --- | --- | --- | --- | --- | --- |
| 读未提交 | Y | Y | Y | Y | Y |
| 读已提交 | N | N | Y | Y | Y |
| 可重复读 | N | N | N | N | Y |
| 串行化 | N | N | N | N | N |

## 数据库锁分类

一般可以分为两类，一个是悲观锁，一个是乐观锁，悲观锁一般就是我们通常说的数据库锁机制，乐观锁一般是指用户自己实现的一种锁机制，比如 `hibernate` 实现的乐观锁甚至编程语言也有乐观锁的思想的应用。

### 悲观锁
它对于数据被外界修改持保守态度，认为数据随时会修改，所以整个数据处理中需要将数据加锁。
悲观锁一般都是依靠关系数据库提供的锁机制，事实上关系数据库中的行锁，表锁不论是读写锁都是悲观锁。
<!-- 联系Java读写锁ReentrantReadWriteLock -->


#### 悲观锁按照使用性质划分：

- **共享锁（Share locks 简记为 S 锁）**：也称读锁，事务 A 对对象 T 加 s 锁，其他事务也只能对 T 加 S，多个事务可以同时读，但不能有写操作，直到 A 释放 S 锁。

- **排它锁（Exclusivelocks 简记为 X 锁）**：也称写锁，事务 A 对对象 T 加 X 锁以后，其他事务不能对 T 加任何锁，只有事务 A 可以读写对象 T 直到 A 释放 X 锁。

- **更新锁（简记为 U 锁）**：**用来预定要对此对象施加 X 锁，它允许其他事务读，但不允许再施加 U 锁或 X 锁**；当被读取的对象将要被更新时，则升级为 X 锁，主要是用来**防止死锁的**。因为使用共享锁时，修改数据的操作分为两步，首先获得一个共享锁，读取数据，然后将共享锁升级为排它锁，然后再执行修改操作。这样如果同时有两个或多个事务同时对一个对象申请了共享锁，在修改数据的时候，这些事务都要将共享锁升级为排它锁。这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。如果一个数据在修改前直接申请更新锁，在数据修改的时候再升级为排它锁，就可以避免死锁。

#### 悲观锁按照作用范围划分：

- **行锁**：锁的作用范围是行级别，数据库能够确定那些行需要锁的情况下使用行锁，如果不知道会影响哪些行的时候就会使用表锁。举个例子，一个用户表 `user`，有主键 `id` 和用户生日 `birthday` 当你使用 `update ... where id=?` 这样的语句数据库明确知道会影响哪一行，它就会使用行锁，当你使用 `update ... where birthday=?` 这样的的语句的时候因为事先不知道会影响哪些行就可能会使用表锁。
- **表锁**：锁的作用范围是整张表。

### 乐观锁
每次自己操作数据的时候认为没有人回来修改它，所以不去加锁，但是**在更新的时候会去判断在此期间数据有没有被修改**，需要用户自己去实现。

既然都有数据库提供的悲观锁可以方便使用为什么要使用乐观锁呢？_对于读操作远多于写操作的时候，大多数都是读取，这时候一个更新操作加锁会阻塞所有读取，降低了吞吐量_。最后还要释放锁，锁是需要一些开销的，我们 _只要想办法解决极少量的更新操作的同步问题_。

换句话说，如果是读写比例差距不是非常大或者你的系统没有响应不及时，吞吐量瓶颈问题，那就不要去使用乐观锁，它增加了复杂度，也带来了额外的风险。
<!-- 乐观锁联系Java--StampedLock的实现stamp -->

#### 乐观锁实现方式：

- **版本号（记为 version）**：就是给数据增加一个版本标识，在数据库上就是表中增加一个 `version` 字段，每次更新把这个字段加 `1`，读取数据的时候把 `version` 读出来，更新的时候比较 `version`，如果还是开始读取的 `version` 就可以更新了，如果现在的 `version` 比老的 `version` 大，说明有其他事务更新了该数据，并增加了版本号，这时候得到一个无法更新的通知，用户自行根据这个通知来决定怎么处理，比如重新开始一遍。这里的关键是判断 `version` 和更新两个动作需要作为一个原子单元执行，否则在你判断可以更新以后正式更新之前有别的事务修改了 `version`，这个时候你再去更新就可能会覆盖前一个事务做的更新，造成第二类丢失更新，所以你可以使用 `update ... where ... and version="old version"` 这样的语句，根据返回结果是 `0` 还是非 `0` 来得到通知，如果是 `0` 说明更新没有成功，因为 `version` 被改了，如果返回非 `0` 说明更新成功。
- **时间戳（timestamp）**：和版本号基本一样，只是通过时间戳来判断而已，**注意时间戳要使用数据库服务器的时间戳不能是业务系统的时间**。
- **待更新字段**：和版本号方式相似，只是不增加额外字段，直接使用有效数据字段做版本控制信息，因为有时候我们可能无法改变旧系统的数据库表结构。假设有个待更新字段叫 `count`, 先去读取这个 `count`, 更新的时候去比较数据库中 `count` 的值是不是我期望的值（即开始读的值），如果是就把我修改的 `count` 的值更新到该字段，否则更新失败。`java` 的基本类型的原子类型对象如 `AtomicInteger` 就是这种思想。
- **所有字段**：和待更新字段类似，只是使用所有字段做版本控制信息，只有所有字段都没变化才会执行更新。

#### 乐观锁几种方式的区别：

新系统设计可以使用 `version` 方式和 `timestamp` 方式，需要增加字段，应用范围是整条数据，不论那个字段修改都会更新 `version`, 也就是说 **两个事务更新同一条记录的两个不相关字段也是互斥的，不能同步进行**。

旧系统不能修改数据库表结构的时候 _使用数据字段作为版本控制信息_，不需要新增字段，**待更新字段方式只要其他事务修改的字段和当前事务修改的字段没有重叠就可以同步进行，并发性更高**。

## mysql 事务隔离级别实战

实践是检验真理的唯一标准，掌握上面的理论之后，我们在数据库上实战一番家里更好地掌握也加深理解，同时有助于解决实际问题。不同数据库很多实现可能不同，这里以 `mysql` 为例讲解各种隔离级别下的情况，测试表为 `user（id,name,gender,passwd,email）`。

### 隔离级别：read-uncommitted

#### 脏读测试流程：
1. A 设置隔离级别为 read-uncommitted（注意这里未声明都是 session 级别，而非全局的），开启事务，查询 id=1 的记录
2. B 设置隔离级别为 read-uncommitted, 开启事务，修改 id=1 的记录，但不提交
3. A 再次查询 id=1 的记录，和第一次查询的比较一下
4. B 事务回滚，A 事务回滚。


![脏读-事务A操作](http://upload-images.jianshu.io/upload_images/2987956-230bd9f3a38d46ae "脏读-事务A操作")
![脏读-事务B操作](http://upload-images.jianshu.io/upload_images/2987956-839ce32fe192bd47 "脏读-事务B操作")
结论：A 读到了 B 没有提交的内容，隔离级别为 read-uncommitted 的时候出现脏读。

#### 第一类更新丢失测试流程：
1. A 设置隔离级别为 read-uncommitted，开启事务，查询 id=1 的记录
2. B 设置隔离级别为 read-uncommitted，开启事务, 查询 id=1 的记录
3. A 修改 id=1 的记录
4. B 修改 id=1 的记录
5. A 提交
6. B 回滚
7. A 在查询一次 id=1 的记录，看看自己的修改是否成功

结论：结果不如我所想的，A 的更新成功了，为什么呢？**A 执行 `update` 语句的时候对该条记录加锁了，B 这时候根本无法修改直至超时，也就是至少在 mysql 中在 read-uncommitted 隔离级别下验证第一类丢失更新**，据了解有的数据库好像可以设置不加锁，如果能够不加锁的话则可以实现，也贴一下图吧。

![第一类更新丢失-事务A操作](https://static.oschina.net/uploads/img/201609/08182606_5JWd.png "第一类更新丢失-事务A操作")
![第一类更新丢失-事务B操作](https://static.oschina.net/uploads/img/201609/08182622_fbD9.png "第一类更新丢失-事务B操作")

#### 不可重复读测试流程（省略）：

结论：流程和测试脏读一样，其实在第一次测试脏读的时候就可以发现会出现不可重复读，A 两次读取 id=1 的数据内容不同。

#### 第二类丢失更新流程：

1.  A 开启事务，查询 order_id=1 的记录
2.  B 开启事务，查询 order_id=1 的记录
3.  A 把查出来的 count 加 1 后更新
4.  B 把查出来的 count 加 1 更新
5.  A 提交，B 也提交

![第二类丢失-事务A操作](http://upload-images.jianshu.io/upload_images/2987956-1a6a6a3c1503b61a "第二类丢失-事务A操作")
![第二类丢失-事务B操作](http://upload-images.jianshu.io/upload_images/2987956-6d15fab5100cba3d "第二类丢失-事务B操作")

结论：A 的更新丢失，我们希望的结果是 3，而实际结果是 2，跟 java 的多线程很像对不对，read-uncommitted 隔离模式下会出现第二类丢失更新。

#### 幻读测试流程：
1.  A 开启事务，查询 user 表所有数据
2.  B 开启事务，新增一条记录
3.  A 再次查询 user 表所有记录，和第一次作比对
4.  A 回滚，B 回滚

![幻读-事务A操作](http://upload-images.jianshu.io/upload_images/2987956-e8d56d0445de0ef8 "幻读-事务A操作")
![幻读-事务B操作](http://upload-images.jianshu.io/upload_images/2987956-d9fe7d2e9d9bdb63 "幻读-事务B操作")

结论：A 两次查询全表数据结果不同，read-uncommitted 隔离模式下会出现幻读。

注：因为后面对这几种异常情况的测试流程基本和上面一样，个别有些差别读者自己注意，另外注意更改隔离级别即可，就能看到对应结果，后面的我只给出进一步能解决的异常测试截图, 结论可以参照前面的对照表。

### 隔离级别：read-committed
##### 脏读测试截图
A:
![](http://upload-images.jianshu.io/upload_images/2987956-5578326685ef4833)
B：
![](http://upload-images.jianshu.io/upload_images/2987956-10d920bf7e152fd9)
结论：A 没有读到 B 没有提交的内容，隔离级别为 read-committed 的时候不会出现脏读。

### 隔离级别：repeatable-read
##### 不可重复读测试截图
A:
![](http://upload-images.jianshu.io/upload_images/2987956-cd2007efbd8bac52)
B：
![](http://upload-images.jianshu.io/upload_images/2987956-0ad2dc34fc526fa3) 
结论：A 两次读取 id=1 的数据内容相同，repeatable-read 隔离模式下不会出现不可重复读。
### 隔离级别：Serializable
##### 幻读测试截图
A:
![](http://upload-images.jianshu.io/upload_images/2987956-a011a25c27325837)
B：
![](http://upload-images.jianshu.io/upload_images/2987956-47aa90aa9d684d50)
结论：因为 A 事务未提交之前，B 事务插入操作无法获得锁而超时，Serializable 隔离模式下不会出现幻读。
