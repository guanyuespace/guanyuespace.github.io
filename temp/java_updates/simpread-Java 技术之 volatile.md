> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 https://www.jianshu.com/p/14fc9d34de33 ![](http://upload-images.jianshu.io/upload_images/53727-af0efc95ce5795fa.png) java 内存模型. png

#### volatile 关键字的两层语义

  当一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：

1.  保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
2.  禁止进行指令重排序。

###### volatile 保证变量的可见性

  每个线程在运行过程中都有自己的工作内存，那么线程 1 在运行的时候，会将共享变量的值拷贝一份放在自己的工作内存当中。那么当线程 2 更改了共享变量的值之后，但是还没来得及写入主存当中，线程 2 转去做其他事情了，那么此时线程 1 是不知道当前的共享变量已经被线程 2 修改了，如果此时线程 1 也修改了当前的共享变量的值，那么最终主内存的值可能不是两个线程所期望的值。
  但是用 volatile 修饰之后就变得不一样了，因为：

1.  使用 volatile 关键字会强制将修改的值立即写入主存；
2.  使用 volatile 关键字的话，当线程 2 进行修改时，会导致线程 1 的工作内存中缓存的共享变量的缓存行无效（反映到硬件层的话，就是 CPU 的 L1 或者 L2 缓存中对应的缓存行无效）；
3.  由于线程 1 的工作内存中缓存的共享变量的缓存行无效，所以线程 1 再次读取共享变量的值时会去主存读取。

  那么在线程 2 修改共享变量的值时（当然这里包括 2 个操作，修改线程 2 工作内存中的值，然后将修改后的值写入内存），会使得线程 1 的工作内存中缓存的共享变量的缓存行无效，然后线程 1 读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。那么此时线程 1 读取到的就是最新的正确的值。以上可以参考上图的 Java 内存模型。
  但是需要注意的是，volatile 关键字并不能保证操作的原子性。

###### volatile 禁止指令重排序

  在前面提到 volatile 关键字能禁止指令重排序，所以 volatile 能在一定程度上保证有序性。volatile 关键字禁止指令重排序有两层意思：
1）当程序执行到 volatile 变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
2）在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。

###### volatile 不保证操作的原子性

  volatile 关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是 volatile 没办法保证对变量的操作的原子性。
  我们知道自增操作是不具备原子性的，它包括读取变量的原始值、进行加 1 操作、写入工作内存。也就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：
  假如某个时刻变量 inc 的值为 10，线程 1 对变量进行自增操作，线程 1 先读取了变量 inc 的原始值，然后线程 1 被阻塞了；
  然后线程 2 对变量进行自增操作，线程 2 也去读取变量 inc 的原始值，由于线程 1 只是对变量 inc 进行读取操作，而没有对变量进行修改操作，所以不会导致线程 2 的工作内存中缓存变量 inc 的缓存行无效，所以线程 2 会直接去主存读取 inc 的值，发现 inc 的值时 10，然后进行加 1 操作，并把 11 写入工作内存，最后写入主存。
  然后线程 1 接着进行加 1 操作，由于已经读取了 inc 的值，注意此时在线程 1 的工作内存中 inc 的值仍然为 10，所以线程 1 对 inc 进行加 1 操作后 inc 的值为 11，然后将 11 写入工作内存，最后写入主存。
  那么两个线程分别进行了一次自增操作后，inc 只增加了 1。
  解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改 volatile 变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的 happens-before 规则中的 volatile 变量规则，但是要注意，线程 1 对变量进行读取操作之后，被阻塞了的话，并没有对 inc 值进行修改。然后虽然 volatile 能保证线程 2 对变量 inc 的值读取是从内存中读取的，但是线程 1 没有进行修改，所以线程 2 根本就不会看到修改的值。根源就在这里，自增操作不是原子性操作，而且 volatile 也无法保证对变量的任何操作都是原子性的。

#### volatile 的原理和实现机制

  前面讲述了源于 volatile 关键字的一些使用，下面我们来探讨一下 volatile 到底如何保证可见性和禁止指令重排序的。下面这段话摘自《深入理解 Java 虚拟机》：
“观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，加入 volatile 关键字时，会多出一个 lock 前缀指令”
  lock 前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供 3 个功能：
  1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
  2）它会强制将对缓存的修改操作立即写入主存；
  3）如果是写操作，它会导致其他 CPU 中对应的缓存行无效。

参考：[http://www.cnblogs.com/dolphin0520/p/3920373.html](https://link.jianshu.com?t=http%3A%2F%2Fwww.cnblogs.com%2Fdolphin0520%2Fp%2F3920373.html)