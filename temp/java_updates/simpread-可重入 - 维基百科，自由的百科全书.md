> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 https://zh.wikipedia.org/wiki/%E5%8F%AF%E9%87%8D%E5%85%A5

若一个[程序](/wiki/%E7%A8%8B%E5%BA%8F "程序")或[子程序](/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F "子程序")可以 “在任意时刻被[中断](/wiki/%E4%B8%AD%E6%96%AD "中断")然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为**可重入**（reentrant 或 re-entrant）的。即当该子程序正在[运行时](/wiki/%E5%9F%B7%E8%A1%8C%E6%9C%9F "执行期")，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的[线程安全](/wiki/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8 "线程安全")不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。

可重入概念是在单线程操作系统的时代提出的。一个[子程序](/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F "子程序")的重入，可能由于自身原因，如执行了 jmp 或者 call，类似于子程序的递归调用；或者由于操作系统的中断响应。UNIX 系统的 [signal](/wiki/%E4%BF%A1%E5%8F%B7_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6) "信号 (计算机科学)") 的处理，即子程序被中断处理程序或者 signal 处理程序调用。所以，可重入也可称作 “异步信号安全”。这里的异步是指信号中断可发生在任意时刻。 重入的子程序，按照后进先出线性序依次执行。

若一个[函数](/wiki/%E5%87%BD%E6%95%B0 "函数")是可重入的，则该函数应当满足下述条件：

*   不能含有静态（全局）非常量数据。
*   不能返回静态（全局）非常量数据的地址。
*   只能处理由调用者提供的数据。
*   不能依赖于[单实例模式](/wiki/%E5%8D%95%E5%AE%9E%E4%BE%8B%E6%A8%A1%E5%BC%8F "单实例模式")资源的锁。
*   调用 (call) 的函数也必需是可重入的。

上述条件就是要求可重入函数使用的所有变量都保存在[呼叫堆叠](/wiki/%E5%91%BC%E5%8F%AB%E5%A0%86%E7%96%8A "呼叫堆叠")的当前[函数栈](/w/index.php?title=%E5%87%BD%E6%95%B0%E6%A0%88&action=edit&redlink=1 "函数栈（页面不存在）")（frame）上，因此同一执行线程重入执行该函数时加载了新的函数帧，与前一次执行该函数时使用的函数帧不冲突、不互相覆盖，从而保证了可重入执行安全。

多 “用户 / 对象 / 进程[优先级](/wiki/%E8%B0%83%E5%BA%A6_(%E8%AE%A1%E7%AE%97%E6%9C%BA) "调度 (计算机)")” 以及[多进程](/w/index.php?title=%E5%A4%9A%E8%BF%9B%E7%A8%8B&action=edit&redlink=1 "多进程（页面不存在）")（Multiple processes），一般会使得对可重入代码的控制变得复杂。同时，IO 代码通常不是可重入的，因为他们依赖于像磁盘这样共享的、单独的（类似[编程](/wiki/%E7%B7%A8%E7%A8%8B "编程")中的[静态](/w/index.php?title=%E9%9D%9C%E6%85%8B&action=edit&redlink=1 "静态（页面不存在）")、[全域](/wiki/%E5%85%A8%E5%9F%9F%E8%AE%8A%E6%95%B8 "全域变数")）资源。

可重入性是[函数编程语言](/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80 "函数编程语言")的关键特性之一。

## 例子

在以下的 [C 语言](/wiki/C%E8%AF%AD%E8%A8%80 "C语言")代码中，函数`f`和函数`g`都不是可重入的。

```c
int g_var = 1;

int f()
{
  g_var = g_var + 2;
  return g_var;
}

int g()
{
  return f() + 2;
}

```

以上代码中，`f`使用了[全局变量](/wiki/%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F "全局变量") _g_var_，所以，如果两个线程同时执行它并访问`g_var`，则返回的结果取决于执行的时间。因此，`f`不可重入。而`g`调用了`f`，所以它也不可重入。

稍作修改后，两个函数都是可重入的：

```c
int f(int i)
{
  return i + 2;
}

int g(int i)
{
  return f(i) + 2;
}

```

## 与线程安全的关系

可重入与[线程安全](/wiki/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8 "线程安全")两个概念都关系到函数处理资源的方式。但是，他们有重大区别

*   可重入概念会影响函数的外部接口，而线程安全只关心函数的实现。
    *   大多数情况下，要将不可重入函数改为可重入的，需要修改函数接口，使得所有的数据都通过函数的调用者提供。
    *   要将非线程安全的函数改为线程安全的，则只需要修改函数的实现部分。一般通过加入[同步机制](/w/index.php?title=%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6&action=edit&redlink=1 "同步机制（页面不存在）")以保护共享的资源，使之不会被几个线程同时访问。
*   操作系统背景与 CPU 调度策略：
    *   可重入是在单线程操作系统背景下，重入的函数或者子程序，按照后进先出的线性序依次执行完毕。
    *   多线程执行的函数或子程序，各个线程的执行时机是由操作系统调度，不可预期的，但是该函数的每个执行线程都会不时的获得 CPU 的时间片，不断向前推进执行进度。
*   可重入函数未必是线程安全的；线程安全函数未必是可重入的。
    *   例如，一个函数打开某个文件并读入数据。这个函数是可重入的，因为它的多个实例同时执行不会造成冲突；但它不是线程安全的，因为在它读入文件时可能有别的线程正在修改该文件，为了线程安全必须对文件加 “同步锁”。
    *   另一个例子，函数在它的函数体内部访问共享资源使用了加锁、解锁操作，所以它是线程安全的，但是却不可重入。因为若该函数一个实例运行到已经执行加锁但未执行解锁时被停下来，系统又启动该函数的另外一个实例，则新的实例在加锁处将转入等待。如果该函数是一个中断处理服务，在中断处理时又发生新的中断将导致资源死锁。`fprintf`函数就是线程安全但不可重入。

下述例子，是线程安全的，但不是可重入的。

```c
int function()
{
 mutex_lock();
 ...
 function body
 ...
 mutex_unlock();
}
```

多线程执行时，获得了[互斥锁](/wiki/%E4%BA%92%E6%96%A5%E9%94%81 "互斥锁")的线程总能获得 CPU 时间片，向前推进执行进度，最终解开互斥锁，使得别的线程也能获得互斥锁进入[临界区](/wiki/%E4%B8%B4%E7%95%8C%E5%8C%BA "临界区")。但是，如果在单线程背景下第一次执行该函数时已经获得互斥锁进入临界区，这时该函数被重入执行，这将在重新申请互斥锁时被饿死 (starvation)，因为获得了互斥锁的该函数的第一次执行将永远没有机会再获得 CPU 时间片。
