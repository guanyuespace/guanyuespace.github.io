# synchronized的可重入性
> [原文地址](https://www.cnblogs.com/cielosun/p/6684775.html)

从 [Java 多线程：线程间通信之 volatile 与 sychronized](http://www.cnblogs.com/cielosun/p/6650161.html) 这篇文章中我们了解了 `synchronized` 的基本特性，知道了一旦有一个线程访问某个对象的 `synchronized` 修饰的方法或代码区域时，该线程则获取这个对象的锁，其他线程不能再调用该对象被 `synchronized` 影响的任何方法。那么，如果这个线程自己调用该对象的其他 `synchronized` 方法，Java 是如何判定的？这就涉及到了 Java 中锁的重要特性：***可重入性***，也就是今天的主题。

<!-- TOC -->

- [synchronized的可重入性](#synchronized%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7)
- [线程安全与可重入性](#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7)
  - [线程安全](#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8)
  - [可重入](#%E5%8F%AF%E9%87%8D%E5%85%A5)
    - [定义](#%E5%AE%9A%E4%B9%89)
    - [可重入的条件](#%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%E6%9D%A1%E4%BB%B6)
  - [可重入与线程安全](#%E5%8F%AF%E9%87%8D%E5%85%A5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8)
- [synchronized 的可重入性](#synchronized-%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E6%80%A7)
  - [synchronized 是可重入锁](#synchronized-%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81)
  - [synchronized 可重入锁的实现](#synchronized-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0)
- [参考文章](#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0)

<!-- /TOC -->

# 线程安全与可重入性

在回答引言的问题前，我们先讲解一下*可重入性*。在线程这块知识中，可重入性常常和线程安全进行对比。

## 线程安全

线程安全函数的概念比较直观，众所周知，*同一进程的不同线程会共享同一主内存，线程的私有栈中只包括 PC, 栈，操作数栈，局部变量数组和动态链接。对共享内存进行读写时，若要保证线程安全，则必须通过加锁的方式。*

## 可重入

### 定义

关于可重入这一概念，我们需要参考维基百科。

```wikipedia
若一个程序或子程序可以 “在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（`reentrant` 或 `re-entrant`）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。
```

### 可重入的条件

- **不在函数内使用静态或全局数据。**
- **不返回静态或全局数据，所有数据都由函数的调用者提供。**
- **使用本地数据（工作内存），或者通过制作全局数据的本地拷贝来保护全局数据。**
- **不调用不可重入函数。**

## 可重入与线程安全

一般而言，可重入的函数一定是线程安全的，反之则不一定成立。在不加锁的前提下，如果一个函数用到了全局或静态变量，那么它不是线程安全的，也不是可重入的。如果我们加以改进，对全局变量的访问加锁，此时它是线程安全的但不是可重入的，因为通常的枷锁方式是针对不同线程的访问（如 Java 的 synchronized），当同一个线程多次访问就会出现问题。只有当函数满足可重入的四条条件时，才是可重入的。

# synchronized 的可重入性

## synchronized 是可重入锁

回到引言里的问题，如果一个获取锁的线程调用其它的 `synchronized` 修饰的方法，会发生什么？

从设计上讲，当一个线程请求一个由其他线程持有的对象锁时，该线程会阻塞。当线程请求自己持有的对象锁时，如果该线程是重入锁，请求就会成功，否则阻塞。

我们回来看 `synchronized``，synchronized` 拥有强制原子性的内部锁机制，是一个可重入锁。因此，在一个线程使用 `synchronized` 方法时调用该对象另一个 `synchronized` 方法，即一个线程得到一个对象锁后再次请求该对象锁，是**永远可以拿到锁的**。

在 Java 内部，同一个线程调用自己类中其他 `synchronized` 方法 / 块时不会阻碍该线程的执行，同一个线程对同一个对象锁是可重入的，同一个线程可以获取同一把锁多次，也就是可以多次重入。原因是 Java 中线程获得对象锁的操作是以线程为单位的，而不是以调用为单位的。

## synchronized 可重入锁的实现

之前谈到过，*每个锁关联一个线程持有者和一个计数器*。当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM 会记下持有锁的线程，并将计数器计为 1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个 `synchronized` 方法 / 块时，计数器会递减，如果计数器为 0 则释放该锁。

# 参考文章
[可重入函数与线程安全函数](http://waret.iteye.com/blog/744169)
[可重入](https://zh.wikipedia.org/wiki/%E5%8F%AF%E9%87%8D%E5%85%A5)
