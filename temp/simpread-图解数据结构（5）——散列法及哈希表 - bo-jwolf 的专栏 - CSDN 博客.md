> [转自](https://blog.csdn.net/bo_jwolf/article/details/9956139)
转载自 [http://www.cppblog.com/guogangj/archive/2009/10/15/98699.html](http://www.cppblog.com/guogangj/archive/2009/10/15/98699.html)

数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表，哈希表有多种不同的实现方法，我接下来解释的是最常用的一种方法——拉链法，我们可以理解为 “链表的数组”，如图：

![](http://www.cppblog.com/images/cppblog_com/guogangj/ds_hashtable1.png)
左边很明显是个数组，数组的每个成员包括一个指针，指向一个链表的头，当然这个链表可能为空，也可能元素很多。我们根据元素的一些特征把元素分配到不同的链表中去，也是根据这些特征，找到正确的链表，再从链表中找出这个元素。

元素特征转变为数组下标的方法就是散列法。散列法当然不止一种，我下面列出三种比较常用的。

## 1，除法散列法
最直观的一种，上图使用的就是这种散列法，公式：
index = value % 16
学过汇编的都知道，求模数其实是通过一个除法运算得到的，所以叫 “除法散列法”。

## 2，平方散列法
求 index 是非常频繁的操作，而乘法的运算要比除法来得省时（对现在的 CPU 来说，估计我们感觉不出来），所以我们考虑把除法换成乘法和一个位移操作。公式：
index = (value * value) >> 28
如果数值分配比较均匀的话这种方法能得到不错的结果，但我上面画的那个图的各个元素的值算出来的 index 都是 0——非常失败。也许你还有个问题，value 如果很大，value * value 不会溢出吗？答案是会的，但我们这个乘法不关心溢出，因为我们根本不是为了获取相乘结果，而是为了获取 index。

## 3，斐波那契（Fibonacci）散列法

平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿 value 本身当作乘数呢？答案是肯定的。

1. 对于 16 位整数而言，这个乘数是 40503
2. 对于 32 位整数而言，这个乘数是 2654435769
3. 对于 64 位整数而言，这个乘数是 11400714819323198485

这几个 “理想乘数” 是如何得出来的呢？这跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，如果你还有兴趣，就到网上查找一下 “斐波那契数列” 等关键字，我数学水平有限，不知道怎么描述清楚为什么，另外斐波那契数列的值居然和太阳系八大行星的轨道半径的比例出奇吻合，很神奇，对么？

对我们常见的 32 位整数而言，公式：
index = (value * 2654435769) >> 28

如果用这种斐波那契散列法的话，那我上面的图就变成这样了：

![](http://www.cppblog.com/images/cppblog_com/guogangj/ds_hashtable2.png)
